
integer = @{ (ASCII_DIGIT)+ }
float = @{ (ASCII_DIGIT)+ ~ "." ~ (ASCII_DIGIT)+ }
string = { ASCII_ALPHANUMERIC* }
string_literal = { "\"" ~ string ~ "\"" }

method_call = { "." ~ ident ~ "(" ~ (stmt ~ ("," ~ stmt)*)? ~ ")" ~ (method_call | member_access) }
member_access = { "." ~ ident }
ident_str = @{ (ASCII_ALPHANUMERIC | "_" )+ }
ident = { ident_str ~ (method_call | member_access)? }

WHITESPACE = _{ " " | NEWLINE }
COMMENT = _{ "/*" ~ (!"*/" ~ ANY)* ~ "*/" | "//" ~ ANY* }

plus = { "+" } 
minus = { "-" }
multi = { "*" }
divide = { "/" }
modulo = { "%" }

logical_and = { "&&" }
logical_or = { "||" }
logical_eq = { "==" }
logical_lt = { "<" }
logical_lte = { "<=" }
logical_gt = { ">" }
logical_gte = { ">=" }
logical_neq = { "!=" }

true_bool = { "true" }
false_bool = { "false" }

bool_lit = { 
    true_bool | 
    false_bool
}

factor = { 
    "(" ~ expr ~ ")" | 
    float |
    integer |
    bool_lit |
    ident | 
    string_literal
}

while_expr = { "while" ~ expr ~ "{" ~ stmt ~ "}" }

idents = { ident ~ ("," ~ ident)* }
for_expr = { "for" ~ idents ~ "in" ~ range_expr ~ "{" ~ "}" }

range_start = { expr }
range_end = { expr }
range_expr = { range_start? ~ ".." ~ range_end? }

// term_op = { multi | divide }

term = { factor ~ ((multi | divide) ~ factor)* }

logical_op = { 
    logical_and | 
    logical_or | 
    logical_eq | 
    logical_lt | 
    logical_lte |
    logical_gt | 
    logical_gte | 
    logical_neq
}

// property_access = { ident ~ "." ~ ident }
assignment_stmt = { ident ~ "=" ~ expr }

expr = {
    assignment_stmt |
    (
        term ~ ((plus | minus) ~ term)* ~
        (logical_op ~ expr)?
    )
}

int_type = { "int" }
float_type = { "float" }
bool_type = { "bool" }
string_type = { "string" }
object_type = { "{" ~ type_field ~ "}" }

non_null_type = { 
    int_type | 
    float_type | 
    bool_type | 
    string_type | 
    object_type |
    ident
}
array_type = { non_null_type ~ "[]" }
maybe_type = { (array_type | non_null_type) ~ "?" }
//maybe_type = { non_null_type ~ "?" }
type_def = { maybe_type | array_type | non_null_type }
//type_def = { non_null_type ~ "?"? }

field_decorator = { "@" ~ ident ~ "(" ~ expr ~ ")" }

const_stmt = { "const" ~ ident ~ type_def? ~ "=" ~ stmt }
let_stmt = { "let" ~ ident ~ type_def ~ "=" ~ expr }
use_stmt = { "use" ~ ident }

struct_field = { ident ~ type_def? ~ ("=" ~ stmt)? }
struct_stmt = { "struct" ~ ident  ~ "{" ~ struct_field* ~ "}" }

struct_init_field = { ident ~ ":" ~ stmt }
struct_init = { ident ~ "{" ~ struct_init_field* ~ "}" }

enum_field_object_field = { ident ~ type_def }
enum_field_object = { "{" ~ enum_field_object_field* ~ "}" }
enum_field_tuple = { "(" ~ ident* ~ ")" }
enum_field = { ident ~ (enum_field_object | enum_field_tuple)? }
enum_stmt = { "enum" ~ ident ~ "{" ~ enum_field* ~ "}" }

type_field = { ident ~ type_def ~ field_decorator* }
type_object = { "{" ~ type_field* ~ "}" }
type_simple = { type_def }
type_stmt = { "type" ~ ident ~ "=" ~ (type_object | type_simple) }

return_stmt = { "return" ~ expr }
break_stmt = { "break" }
continue_stmt = { "continue" }

function_arg = { ident ~ type_def? }
function_args = { function_arg ~ ("," ~ function_arg)* }
normal_func = { "("? ~ function_args? ~ ")"? ~ "=>" ~ (block_stmt | stmt) }
async_func = { "async" ~ normal_func }
function_stmt = { async_func | normal_func  }

object_stmt_field = { ident ~ ":" ~ expr }
object_stmt = { "{" ~ object_stmt_field* ~ "}" }

if_branch = { "if" ~ expr ~ "{" ~ stmts? ~ "}" }
else_if_branch = { "else if" ~ expr ~ "{" ~ stmts? ~ "}" }
else_branch = { "else" ~ "{" ~ stmts? ~ "}" }
if_stmt = { if_branch ~ else_if_branch* ~ else_branch? }

match_condition = { expr ~ ( "|" ~ match_condition )* }
match_case = { ( "_" | match_condition ) ~ "=>" ~ block_stmt | stmt }
match_stmt = { "match" ~ stmt ~ "{" ~ match_case* ~ "}" }

xml_atribute = { ident ~ "=" ~ ( string_literal | "{" ~ stmt ~ "}" ) }
xml_var = { "{" ~ stmt ~ "}" }
xml_child = { xml_stmt | xml_var | ident_str }
xml_start = { "<" ~ ident ~ xml_atribute*}
xml_end = { "</" ~ ident ~ ">" }
xml_stmt = { xml_start ~ ("/>" | ">" ~ xml_child* ~ xml_end) }

call_args = { stmt ~ ("," ~ stmt)* }
call_stmt = { expr? ~ "(" ~ call_args? ~ ")" }

array_items = { stmt ~ ("," ~ stmt)* }
array_stmt = { "[" ~ array_items* ~ "]" }


sql_select_parameters = { ident ~ ("," ~ ident)? }
sql_from = { "from" ~ ident ~ ("as" ~ ident)? }
sql_where_condition = { ident ~ "==" ~ expr ~ ( ( "and" | "or" ) ~ sql_where_condition )? }
sql_where = { "where" ~ ident ~ "==" ~ stmt }
sql_select = { "select" ~ sql_select_parameters ~ sql_from ~ sql_where }
sql_insert = { "insert" ~ "into" ~ ident ~ "(" ~ ident ~ ")" ~ "values" ~ "(" ~ stmt ~ ")" }
sql_update = { "update" ~ ident ~ "set" ~ ident ~ "=" ~ stmt ~ sql_where }
sql_stmt = { sql_select | sql_insert | sql_update }

default_export = { "export" ~ "default" ~ stmt }
named_export = { "export" ~ ident ~ stmt }

export = { default_export | named_export }

block_stmt = { "{" ~ stmts? ~ "}" }

stmt = {
    struct_stmt |
    for_expr |
    const_stmt |
    let_stmt |
    if_stmt |
    use_stmt |
    enum_stmt |
    struct_init |
    type_stmt |
    return_stmt |
    break_stmt |
    continue_stmt |
    function_stmt |
    range_expr |
    object_stmt |
    match_stmt |
    block_stmt |
    xml_stmt |
    call_stmt |
    array_stmt |
    sql_stmt |
    export |
    expr 
}

// stmt = {
//     sql_stmt
// }

stmts = { stmt* }

file = { SOI ~  stmts? ~ EOI }